<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">src/services/utils/projextPlugin.js | projext-plugin-runner</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="A projext plugin to run Node targets with a simple command no matter the environment."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="projext-plugin-runner"><meta property="twitter:description" content="A projext plugin to run Node targets with a simple command no matter the environment."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/homer0/projext-plugin-runner"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Provider">Provider</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ProviderRegisterMethod">ProviderRegisterMethod</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RunnerFileContents">RunnerFileContents</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Target">Target</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://tj.github.io/commander.js/#Command">Command</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://yarnpkg.com/en/package/jimple">Jimple</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://homer0.github.io/wootils/class/wootils/node/pathUtils.js~PathUtils.html">PathUtils</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://homer0.github.io/projext/class/src/app/index.js~Projext.html">Projext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://homer0.github.io/projext/typedef/index.html#static-typedef-Target">ProjextTarget</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#abstracts">abstracts</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/abstracts/cliCommand.js~CLICommand.html">CLICommand</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#app">app</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/app/index.js~ProjextRunner.html">ProjextRunner</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#services-cli">services/cli</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/services/cli/cli.js~CLI.html">CLI</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/services/cli/cliSHRun.js~CLISHRunCommand.html">CLISHRunCommand</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/services/cli/cliSHValidate.js~CLISHValidateCommand.html">CLISHValidateCommand</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-cliWithName">cliWithName</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-cli">cli</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-cliSHRunCommand">cliSHRunCommand</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-cliSHValidateCommand">cliSHValidateCommand</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#services-runner">services/runner</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/services/runner/file.js~RunnerFile.html">RunnerFile</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/services/runner/runner.js~Runner.html">Runner</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/services/runner/targets.js~Targets.html">Targets</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-runnerFile">runnerFile</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-runner">runner</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-targets">targets</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#services-utils">services/utils</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/services/utils/projextPlugin.js~ProjextPlugin.html">ProjextPlugin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-projextPlugin">projextPlugin</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/services/utils/projextPlugin.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">const { provider } = require(&apos;jimple&apos;);
/**
 * This service handles all interaction between the plugin and projext. It takes care of validating
 * if projext is installed, registering the necessary events and generating the build commands for
 * when the plugin is used on a development environment.
 */
class ProjextPlugin {
  /**
   * Class constructor.
   * @param {Object}     info       The plugin&apos;s `package.json`. The service uses it to get the
   *                                name and send it on the build commands as the `--plugin` flag.
   * @param {RunnerFile} runnerFile To be able to update the runner file when a target is built.
   */
  constructor(info, runnerFile) {
    /**
     * The name of the plugin as it&apos;s defined on the `package.json`. It&apos;s used on the generated
     * build command(s) as the `--plugin` option. The flag is verified by the plugin in order to
     * building dependencies (other targets) when a target is running on a development
     * environment.
     * @type {string}
     */
    this.pluginName = info.name;
    /**
     * A local reference for the `runnerFile` service.
     * @type {RunnerFile}
     */
    this.runnerFile = runnerFile;
    /**
     * The name of the option flag the service will add on the build commands.
     * @type {string}
     */
    this._pluginFlagName = &apos;plugin&apos;;
    /**
     * Whether or not projext is installed on the current environment.
     * @type {boolean}
     * @ignore
     * @access protected
     */
    this._installed = this._detectInstallation();
    /**
     * When running along side projext, when the plugin gets registered, this property will hold a
     * reference to the projext instance.
     * @type {?Projext}
     * @ignore
     * @access protected
     */
    this._instance = null;
  }
  /**
   * Check whether projext is installed or not.
   * @return {boolean}
   */
  isInstalled() {
    return this._installed;
  }
  /**
   * Register all the necessary events for the plugin to work:
   * - Update the target information on the runner file when the target build command is generated.
   * - Add the runner file to the list of files projext copies.
   * - Update the runner file version when the revision file is created.
   *
   * @param {Projext} instance The projext instance that is registering the plugin.
   */
  registerPlugin(instance) {
    this._setInstance(instance);
    const events = this.get(&apos;events&apos;);
    events.once(&apos;build-target-commands-list&apos;, (commands, params, unknownOptions) =&gt; (
      this._updateBuildCommands(commands, params, unknownOptions)
    ));

    events.once(&apos;project-files-to-copy&apos;, (list) =&gt; this._updateCopyList(list));
    events.once(&apos;revision-file-created&apos;, (version) =&gt; this._updateFileVersion(version));
  }
  /**
   * Get a service from projext.
   * @param {string} service The service name.
   * @return {*}
   * @throws {Error} If the plugin hasn&apos;t been registered.
   */
  get(service) {
    if (!this._instance) {
      throw new Error(&apos;You can\&apos;t access projext services if the plugin is not installed&apos;);
    }

    return this._instance.get(service);
  }
  /**
   * Generate a projext build command for one or more targets.
   * @param {string|Array} target                    A target name or a list of them.
   * @param {Object}       [args={}]                 A dictionary of arguments and their values to
   *                                                 send on the command. If this dictionary
   *                                                 contains a `target` key, it will be ignored
   *                                                 and removed, since it&apos;s the one used to send
   *                                                 the target name this method uses as parameter.
   * @param {string}       [environmentVariables=&apos;&apos;] Environment variables to prefix the command
   *                                                 with. For example: `NODE_ENV=production`.
   * @return {Array} No matter if you used a single (`string`) target or a list (`Array`), it will
   *                 always return a list (`Array`) of commands.
   */
  getBuildCommandForTarget(target, args = {}, environmentVariables = &apos;&apos;) {
    const list = Array.isArray(target) ? target : [target];
    const newArgs = Object.assign({}, args);
    delete newArgs.target;
    const result = list
    .map((name) =&gt; (
      this.getBuildCommand(
        Object.assign(
          { target: name },
          newArgs
        ),
        environmentVariables
      )
    ));

    return result;
  }
  /**
   * Generate a projext build command. If not overwritten by the `args` parameter, this method
   * sends an empty `target` and a `plugin` argument with the value of the `pluginName` property.
   * @param {Object} args                      A dictionary of arguments and their values to send
   *                                           on the command.
   * @param {string} [environmentVariables=&apos;&apos;] Environment variables to prefix the command with.
   *                                           For example: `NODE_ENV=production`
   * @return {string}
   * @throws {Error} If projext is not installed and/or it couldn&apos;t access is instance.
   */
  getBuildCommand(args, environmentVariables = &apos;&apos;) {
    this._loadInstalledInstanceIfNeeded();
    if (!this.isInstalled() || !this._instance) {
      throw new Error(&apos;You can\&apos;t generate a build command if projext is not installed&apos;);
    }
    // Get the environment variables to append to the command.
    const env = environmentVariables ? `${environmentVariables} ` : &apos;&apos;;
    // Get the service that will generate the build command.
    const projextCLIBuildCommand = this.get(&apos;cliBuildCommand&apos;);
    /**
     * If the projext CLI was instantiated, the service will have the name of the program, as it
     * gets set when the commands get registered; but if not, it means that we need to go to main
     * CLI service and get it from there.
     */
    let program = &apos;&apos;;
    if (!projextCLIBuildCommand.cliName) {
      const cliName = this.get(&apos;cli&apos;).name;
      program = `${cliName} `;
    }
    // Generate the build command
    const command = projextCLIBuildCommand.generate(Object.assign(
      {
        target: &apos;&apos;,
        [this._pluginFlagName]: this.pluginName,
      },
      args
    )).trim();
    // Prepend the environment variables and the program name, if needed.
    const result = `${env}${program}${command}`;
    // Return the final command.
    return result;
  }
  /**
   * Set the projext instance.
   * @param {Projext} instance The projext instance accessed either from registering the plugin or
   *                           by requiring the module directly.
   */
  _setInstance(instance) {
    this._instance = instance;
  }
  /**
   * Get an instance of projext by requiring the module.
   * @return {?Projext} If something is wrong with the module or projext is not installed, it will
   *                    return `null`.
   */
  _getInstalledInstance() {
    let instance;
    try {
      // eslint-disable-next-line global-require, node/no-missing-require, import/no-unresolved
      instance = require(&apos;projext/index&apos;);
    } catch (ignore) {
      instance = null;
    }

    return instance;
  }
  /**
   * If projext is installed but the plugin wasn&apos;t registerd (probably because the plugin was
   * executed from its own CLI), this method will try to set the instance by requiring the module.
   */
  _loadInstalledInstanceIfNeeded() {
    if (this.isInstalled() &amp;&amp; !this._instance) {
      this._setInstance(this._getInstalledInstance());
    }
  }
  /**
   * Detect whether or not projext is installed on the current environment.
   * @return {boolean}
   */
  _detectInstallation() {
    let installed = true;
    try {
      // eslint-disable-next-line global-require, node/no-missing-require, import/no-unresolved
      require(&apos;projext&apos;);
    } catch (ignore) {
      installed = false;
    }

    return installed;
  }
  /**
   * This method gets called when projext is creating the build commands for a target. It takes
   * care of updating the runner file with the target information and, if the target needs other
   * targes to be built first in order to run, injecting the commands for building those targets.
   * @param {Array}                 commands       The list of commands projext uses to build and
   *                                               run the target.
   * @param {CLIBuildCommandParams} params         A dictionary with all the required information
   *                                               the service needs to run the command: The
   *                                               target information, the build type, whether or
   *                                               not the target will be executed, etc.
   * @param {Object}                unknownOptions Like `options`, this is also a dictionary of
   *                                               options the original command received, the
   *                                               difference is that these ones are unknown by
   *                                               the command, as they were probably injected by
   *                                               an event. In this case, the method checks if
   *                                               the plugin option the `getBuildCommand` method
   *                                               adds is present in order to determine whether
   *                                               it should add the build commands for the
   *                                               dependencies or not.
   * @return {Array} The updated list of commands.
   */
  _updateBuildCommands(commands, params, unknownOptions) {
    // Get the distribution directory path.
    const distPath = this.get(&apos;projectConfiguration&apos;).getConfig().paths.build;
    // Get the project version.
    const version = this.get(&apos;buildVersion&apos;).getVersion();
    // Save the target information on the runner file and get it once it&apos;s parsed.
    const targetInfo = this.runnerFile.update(params.target, version, distPath);
    // Define the list of commands that are going to be returned.
    let updatedCommands;
    /**
     * If the build command was ran from the plugin, the target type is `node` (a browser target
     * wouldn&apos;t return anything from `runnerFile.update`) and it needs other targets to be built
     * before running...
     */
    if (
      unknownOptions[this._pluginFlagName] === this.pluginName &amp;&amp;
      params.type === &apos;production&apos; &amp;&amp;
      targetInfo &amp;&amp;
      targetInfo.options.build
    ) {
      // Get the commands for the other targets.
      const newCommands = this.getBuildCommandForTarget(
        targetInfo.options.build,
        Object.assign(
          {},
          unknownOptions,
          { type: params.type }
        )
      );
      // Push them first on the list of commands projext will run.
      updatedCommands = [
        ...newCommands,
        ...commands,
      ];
    } else {
      // ...otherwise, keep the list as it was received.
      updatedCommands = commands;
    }

    // Return the list of commands for projext to run.
    return updatedCommands;
  }
  /**
   * This method gets called when projext is copying the project files to the distribution
   * directory. It just adds the runner file to the list and returns it.
   * @param {Array} list The list of files projext is going to copy.
   * @return {Array} An updated list of files, with the runner file on it.
   */
  _updateCopyList(list) {
    return [
      ...list,
      this.runnerFile.getFilename(),
    ];
  }
  /**
   * This method gets called when projext is generating a revision file and it takes care of
   * updating the runner file with the generated version.
   * @param {string} version The new version for the revision file.
   */
  _updateFileVersion(version) {
    this.runnerFile.updateVersion(version);
  }
}
/**
 * The service provider that once registered on the app container will set an instance of
 * `ProjextPlugin` as the `projextPlugin` service.
 * @example
 * // Register it on the container
 * container.register(projextPlugin);
 * // Getting access to the service instance
 * const projextPlugin = container.get(&apos;projextPlugin&apos;);
 * @type {Provider}
 */
const projextPlugin = provider((app) =&gt; {
  app.set(&apos;projextPlugin&apos;, () =&gt; new ProjextPlugin(
    app.get(&apos;info&apos;),
    app.get(&apos;runnerFile&apos;)
  ));
});

module.exports = {
  ProjextPlugin,
  projextPlugin,
};
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
