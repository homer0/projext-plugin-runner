<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/abstracts/cliCommand.js | projext-plugin-runner</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="A projext plugin to run Node targets with a simple command no matter the environment."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="projext-plugin-runner"><meta property="twitter:description" content="A projext plugin to run Node targets with a simple command no matter the environment."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/homer0/projext-plugin-runner"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Provider">Provider</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ProviderRegisterMethod">ProviderRegisterMethod</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RunnerFileContents">RunnerFileContents</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Target">Target</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://tj.github.io/commander.js/#Command">Command</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://yarnpkg.com/en/package/jimple">Jimple</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://homer0.github.io/wootils/class/wootils/node/pathUtils.js~PathUtils.html">PathUtils</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://homer0.github.io/projext/class/src/app/index.js~Projext.html">Projext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://homer0.github.io/projext/typedef/index.html#static-typedef-Target">ProjextTarget</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#abstracts">abstracts</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/abstracts/cliCommand.js~CLICommand.html">CLICommand</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#app">app</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/app/index.js~ProjextRunner.html">ProjextRunner</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#services-cli">services/cli</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/services/cli/cli.js~CLI.html">CLI</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/services/cli/cliSHRun.js~CLISHRunCommand.html">CLISHRunCommand</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/services/cli/cliSHValidate.js~CLISHValidateCommand.html">CLISHValidateCommand</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-cliWithName">cliWithName</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-cli">cli</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-cliSHRunCommand">cliSHRunCommand</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-cliSHValidateCommand">cliSHValidateCommand</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#services-runner">services/runner</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/services/runner/file.js~RunnerFile.html">RunnerFile</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/services/runner/runner.js~Runner.html">Runner</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/services/runner/targets.js~Targets.html">Targets</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-runnerFile">runnerFile</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-runner">runner</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-targets">targets</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#services-utils">services/utils</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/services/utils/projextPlugin.js~ProjextPlugin.html">ProjextPlugin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-projextPlugin">projextPlugin</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/abstracts/cliCommand.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * A helper class for creating commands for the CLI.
 * @abstract
 * @version 1.0
 */
class CLICommand {
  /**
   * Class constructor.
   * @throws {TypeError} If instantiated directly.
   * @abstract
   */
  constructor() {
    if (new.target === CLICommand) {
      throw new TypeError(
        &apos;CLICommand is an abstract class, it can\&apos;t be instantiated directly&apos;
      );
    }
    /**
     * The CLI command instruction. For example `my-command [target]`.
     * @type {string}
     */
    this.command = &apos;&apos;;
    /**
     * A description of the command for the help interface.
     * @type {string}
     */
    this.description = &apos;&apos;;
    /**
     * A more complete description of the command to show when the command help interface is
     * invoked.
     * If left empty, it won&apos;t be used.
     * @type {string}
     */
    this.fullDescription = &apos;&apos;;
    /**
     * A list with the name of the options the command supports. New options can be added using
     * the `addOption` method.
     * @type {Array}
     */
    this.options = [];
    /**
     * A dictionary of command options settings by their option name. New options can be added
     * using the `addOption` method.
     * @type {Object}
     */
    this.optionsByName = {};
    /**
     * This is a useful flag for when the command is ran as a result of another command. It lets
     * the interface know that it can search for option values on a parent command, if there&apos;s one.
     * @type {boolean}
     */
    this.checkOptionsOnParent = true;
    /**
     * Whether the command and its description should be shown on the CLI interface list of
     * commands.
     * @type {boolean}
     */
    this.hidden = false;
    /**
     * Whether or not a sub program should be executed for this command. Take for example the case
     * of `git`, where `git checkout [branch]` executes `git` as main program, and `checkout` as a
     * sub program. If this is `true`, then a binary with the name of the command should be
     * exported on the `package.json`.
     * @type {boolean}
     */
    this.subProgram = false;
    /**
     * This is the name of the program that runs the command. It will be added when the command
     * is registered on the program.
     * @type {string}
     */
    this.cliName = &apos;&apos;;
    /**
     * Whether or not the command supports unknown options. If it does, it will be sent to the
     * `onActivation` method as a parameter.
     * @type {Boolean}
     */
    this.allowUnknownOptions = false;
    /**
     * This dictionary will be completed when the command gets activated. If the command supports
     * unknown options (`allowUnknownOptions`), they&apos;ll be parsed and sent to the `handle` method
     * as the last parameter.
     * @type {Object}
     */
    this._unknownOptions = {};
    /**
     * Once registered on the program, this property will hold a reference to the real command
     * the program generates.
     * @type {?Command}
     * @ignore
     * @access protected
     */
    this._command = null;
  }
  /**
   * Add a new option for the command.
   * @example
   * // To capture an option
   * this.addOption(
   *   &apos;type&apos;,
   *   &apos;-t, --type [type]&apos;,
   *   &apos;The type of thingy you want to use?&apos;,
   * );
   *
   * // As a simple flag
   * this.addOption(
   *   &apos;ready&apos;,
   *   &apos;-r, --ready&apos;,
   *   &apos;Is it read?&apos;,
   *   false
   * );
   *
   * @param {string} name              The option name.
   * @param {string} instruction       The option instruction, for example: `-t, --type [type]`.
   * @param {string} [description=&apos;&apos;]  The option description.
   * @param {string} [defaultValue=&apos;&apos;] The option default value, in case is not used on execution.
   */
  addOption(name, instruction, description = &apos;&apos;, defaultValue = &apos;&apos;) {
    this.optionsByName[name] = {
      name,
      instruction,
      description,
      defaultValue,
    };

    this.options.push(name);
  }
  /**
   * Register this command on a CLI program.
   * @param {Command} program  A Commander instance.
   * @param {Object}  cli      The main CLI interface, just for the name.
   * @param {string}  cli.name The CLI interface name.
   * @see https://yarnpkg.com/en/package/commander
   */
  register(program, cli) {
    // Get the real name of the command.
    const commandName = this.command.replace(/\[\w+\]/g, &apos;&apos;).trim();
    // Set a listener on the program in order to detect when it gets executed.
    program.on(`command:${commandName}`, (args, unknown) =&gt; this._onActivation(args, unknown));
    // Get the name of the program
    this.cliName = cli.name;
    const options = {};
    // If the command should be hidden...
    if (this.hidden) {
      // ...remove it from the help interface.
      options.noHelp = true;
    }

    let command;
    // If the command is a sub program...
    if (this.subProgram) {
      /**
       * ...it gets added without the `.description` property. That&apos;s how Commander differentiates
       * a main program command and a sub program command.
       */
      command = program.command(this.command, this.description, options);
    } else {
      // ...otherwise, it gets added as a sub command of the main program.
      command = program
      .command(this.command, &apos;&apos;, options)
      .description(this.description);
    }
    // Register all the command options.
    this.options.forEach((name) =&gt; {
      const option = this.optionsByName[name];
      command = command.option(
        option.instruction,
        option.description
      );
    });
    // Add the handler for when the command gets executed.
    command.action(this._handle.bind(this));
    // Enable unknown options if the command supports it
    command.allowUnknownOption(this.allowUnknownOptions);
    // Save the reference
    this._command = command;
  }
  /**
   * Generate an instruction for this command.
   * @example
   * // Let&apos;s say this command is `destroy [target] [--once]`
   *
   * this.generate({ target: &apos;pluto&apos; });
   * // Will return `destroy pluto`
   *
   * this.generate({ target: &apos;moon&apos;, once: true });
   * // Will return `destroy moon --once`
   * @param  {Object} [args={}] A dictionary with the arguments and options for the command. If the
   *                            command includes an argument on its `command` property, that
   *                            argument is required.
   * @return {string} The command instruction to run on the CLI interface.
   */
  generate(args = {}) {
    let cmd = this.command;
    const cmdOptions = [];
    // Loop all the `args`...
    Object.keys(args).forEach((name) =&gt; {
      const value = args[name];
      const asPlaceholder = `[${name}]`;
      // Check if the current argument should be used on the command instruction...
      if (cmd.includes(asPlaceholder)) {
        // ...if so, replace it on the main command.
        cmd = cmd.replace(asPlaceholder, value);
      } else if (this.optionsByName[name]) {
        // ...otherwise, check if there&apos;s an option with the same name as the argument.
        const option = this.optionsByName[name];
        /**
         * Remove the shorthand version of the option instruction, if there&apos;s one. For example:
         * `-t, --type [type]` -&gt; `--type [type]`.
         */
        let instruction = option.instruction.split(&apos;,&apos;).pop().trim();
        // If the option instruction includes the argument as a value (`[argument-name]`)...
        if (instruction.includes(asPlaceholder)) {
          // ...replace it on the option instruction.
          instruction = instruction.replace(asPlaceholder, value);
        } else if (value === false) {
          /**
           * ...but if the value is `false`, then we clear the instruction as it won&apos;t be included
           * on the generated string.
           */
          instruction = &apos;&apos;;
        }

        // If there&apos;s an option instruction...
        if (instruction) {
          // ...add it to the list.
          cmdOptions.push(instruction);
        }
      } else if (this.allowUnknownOptions) {
        /**
         * Finally, if is not on the command options and the command supports unknown options,
         * just add it.
         */
        let instruction = `--${name}`;
        // If the option is not a flag, add its value.
        if (value !== true) {
          instruction += ` ${value}`;
        }
        // Push it to the list
        cmdOptions.push(instruction);
      }
    });

    let options = &apos;&apos;;
    // If after the loop, there are option instructions to add...
    if (cmdOptions.length) {
      // ...put them all together on a single string, separated by a space
      options = [&apos;&apos;, ...cmdOptions].join(&apos; &apos;);
    }

    // Return the complete command instruction
    return `${this.cliName} ${cmd}${options}`;
  }
  /**
   * Handle the command execution.
   * This method will receive first the captured arguments, then the executed command information
   * from Commander and finally, a dictionary with the options and their values.
   * @example
   * // Let&apos;s say the command is `run [target] [--production]`.
   * // And now, it was executed with `run my-target`
   * handle(target, command, options) {
   *   console.log(target);
   *   // Will output `my-target`
   *   console.log(options.production)
   *   // Will output `false`
   * }
   * @throws {Error} if not overwritten.
   * @abstract
   */
  handle() {
    throw new Error(&apos;This method must to be overwritten&apos;);
  }
  /**
   * A simple wrapper for a `console.log`. Outputs a variable to the CLI interface.
   * @param {string} text The text to output.
   */
  output(text) {
    // eslint-disable-next-line no-console
    console.log(text);
  }
  /**
   * This is the real method that receives the execution of the command and parses it in order to
   * create the options dictionary that the `handle` method receives.
   * @param {Array} args The list of arguments sent by Commander.
   * @ignore
   * @access protected
   */
  _handle(...args) {
    // The actual command is always the last argument.
    const command = args[args.length - 1];
    const options = {};
    // Loop all the known options the command can receive
    Object.keys(this.optionsByName).forEach((name) =&gt; {
      const option = this.optionsByName[name];
      let value = &apos;&apos;;
      // If the option is on the command...
      if (command[name]) {
        // ...then that&apos;s the value that will be used.
        value = command[name];
      }

      /**
       * If no value was found yet, the flag to check on the parent is `true`, there&apos;s a parent
       * command and it has an option with that name...
       */
      if (
        !value &amp;&amp;
        this.checkOptionsOnParent &amp;&amp;
        command.parent &amp;&amp;
        command.parent[name]
      ) {
        // ...then that&apos;s the value that will be used.
        value = command.parent[name];
      }
      // If no value was found and there&apos;s a default value registered for the option...
      if (!value &amp;&amp; typeof option.defaultValue !== &apos;undefined&apos;) {
        // ...then that&apos;s the value that will be used.
        value = option.defaultValue;
      }

      // Set the option on the dictionary with the value found.
      options[name] = value;
    });

    // Copy the arguments list.
    const newArgs = args.slice();
    // Add the new options dictionary.
    newArgs.push(options);
    // If the method supports unknown options, add them as the last argument.
    if (this.allowUnknownOptions) {
      newArgs.push(this._unknownOptions);
    }
    // Call the abstract method that handles the execution.
    this.handle(...newArgs);
  }
  /**
   * This method gets called by the program when the command is executed and it takes care of
   * switching the descriptions, if needed, and parsing the unknown options, if supported.
   * @param {Array} args        The list of known arguments the command received.
   * @param {Array} unknownArgs The list of unknown arguments the command received.
   * @ignore
   * @protected
   */
  _onActivation(args, unknownArgs) {
    // Switch the descriptions.
    this._updateDescription();
    // If unknown options are allowed, parsed them and save them on the local property.
    if (this.allowUnknownOptions &amp;&amp; unknownArgs &amp;&amp; unknownArgs.length) {
      this._unknownOptions = this._parseArgs(unknownArgs);
    }
  }
  /**
   * This method gets called when the command is executed on the program and before reaching the
   * handle method. It checks if the command has a different description for when it gets
   * executed, and if needed, it switches it on the program.
   * @ignore
   * @access protected
   */
  _updateDescription() {
    // If the command reference is available and there&apos;s a full description...
    if (this.fullDescription) {
      // ...normalize it by adding the indentation the program uses to show descriptions and help.
      const normalizedDescription = this.fullDescription.replace(/\n/g, &apos;\n  &apos;);
      // Change the command description.
      this._command.description(normalizedDescription);
    }
  }
  /**
   * This method parses a list of CLI arguments into a dicitionary.
   * @example
   * const args = [
   *   &apos;--include=something&apos;,
   *   &apos;-i&apos;,
   *   &apos;somes&apos;,
   *   &apos;--exclude&apos;,
   *   &apos;--type&apos;,
   *   &apos;building&apos;,
   *   &apos;-x=y&apos;,
   * ];
   * console.log(this._parseArgs(args));
   * // Will output `{include: &apos;something&apos;, i: &apos;somes&apos;, exclude: true, type: &apos;building&apos;, x: &apos;y&apos;}`
   * @param {Array} args A list of arguments.
   * @return {Object}
   * @ignore
   * @access protected
   */
  _parseArgs(args) {
    // Use Commander to normalize the arguments list.
    const list = this._command.normalize(args);
    // Define the dictionary to return.
    const parsed = {};
    /**
     * Define the regex that will validate if an argument is an _&quot;option header&quot;_ (`--[something]`)
     * or a value.
     */
    const headerRegex = /^-(?:-)?/;
    /**
     * Every time the loop finds a header, it will be set on this variable, so the next time a value
     * is found, it can be assigned to that header on the return dictionary.
     */
    let currentHeader;
    /**
     * The commander `normalize` method transforms `-x=y` into `[&apos;-x&apos;, &apos;-=&apos;, &apos;-y&apos;]`. On the first
     * iteration, `-x` will be marked as a header, on the following iteration, the loop will check
     * for `-=`, ignore it and mark this variable as `true` so on the final iteration, despite the
     * fact that the value starts `-`, the method should remove the `-` and save it as a value for
     * `-x`.
     */
    let nextValue = false;
    // Loop the list...
    list.forEach((item) =&gt; {
      // Check whether the current item is a header or not.
      const isHeader = item.match(headerRegex);
      // If it is a header...
      if (isHeader) {
        // ...and the flag for short instructions is `true`...
        if (nextValue) {
          // ...remove the leading `-` and save it as a value for the current header.
          parsed[currentHeader] = item.substr(1);
          // Reset the flags.
          currentHeader = null;
          nextValue = false;
        } else if (currentHeader &amp;&amp; item === &apos;-=&apos;) {
          /**
           * If there&apos;s a header and the current argument is `-=`, set the flag for short
           * instructions to `true`.
           */
          nextValue = true;
        } else if (currentHeader) {
          /**
           * If this is another header, it means that the argument is a flag, so save the current
           * header as `true` and change the current header to the current item.
           */
          parsed[currentHeader] = true;
          currentHeader = item.replace(headerRegex, &apos;&apos;);
        } else {
          // Set the current header to the current item.
          currentHeader = item.replace(headerRegex, &apos;&apos;);
        }
      } else if (currentHeader) {
        /**
         * If there&apos;s a header, this means the current item is a value, so set it to the current
         * header and reset the variable.
         */
        parsed[currentHeader] = item;
        currentHeader = null;
      }
    });
    // Return the parsed object.
    return parsed;
  }
}

module.exports = CLICommand;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
